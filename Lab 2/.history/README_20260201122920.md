# GIẢI THÍCH CODE TCP/UDP

## MỤC LỤC
- [Kiến thức nền tảng](#kiến-thức-nền-tảng)
- [Bài 1: Giải phương trình bậc 2](#bài-1-giải-phương-trình-bậc-2)
- [Bài 2: Nhân hai ma trận](#bài-2-nhân-hai-ma-trận)
- [Bài 3: Thay thế chuỗi trong file](#bài-3-thay-thế-chuỗi-trong-file)
- [Bài 4: Xử lý chuỗi](#bài-4-xử-lý-chuỗi)
- [Bài 5: Chat room](#bài-5-chat-room)

---

## Kiến thức nền tảng

### TCP (Transmission Control Protocol)

**Đặc điểm:**
- **Connection-oriented**: Phải thiết lập kết nối trước (3-way handshake)
- **Reliable**: Đảm bảo dữ liệu đến đích đầy đủ, đúng thứ tự
- **Flow control**: Kiểm soát tốc độ gửi/nhận để không bị tràn
- **Error checking**: Tự động phát hiện lỗi và gửi lại gói tin bị mất
- **Overhead**: Tốn tài nguyên hơn (header 20-60 bytes)

**Cơ chế 3-way handshake:**
```
Client                    Server
  │                         │
  │────── SYN ─────────────>│  (Xin kết nối)
  │                         │
  │<───── SYN-ACK ──────────│  (Đồng ý + xác nhận)
  │                         │
  │────── ACK ─────────────>│  (Xác nhận hoàn tất)
  │                         │
  └─── Kết nối thành công ──┘
```

**Ví dụ:**
```javascript
// TCP Server - net.createServer()
const server = net.createServer((socket) => {
    // socket đại diện cho 1 kết nối cố định
    socket.on('data', (data) => {
        // Nhận dữ liệu từ chính kết nối đó
        socket.write(result);  // Gửi lại cho chính client đó
    });
});

// TCP Client - client.connect()
client.connect(5000, '127.0.0.1', () => {
    // Phải kết nối trước mới gửi được
    client.write('Hello');  // Gửi qua kết nối đã thiết lập
});
```

### UDP (User Datagram Protocol)

**Đặc điểm:**
- **Connectionless**: Không cần thiết lập kết nối, gửi trực tiếp
- **Unreliable**: Không đảm bảo dữ liệu đến đích (có thể mất gói tin)
- **No ordering**: Gói tin có thể đến không đúng thứ tự gửi
- **Fast**: Nhanh hơn TCP (không có overhead kết nối)
- **Overhead**: Nhẹ hơn (header chỉ 8 bytes)

**Cơ chế gửi nhận:**
```
Client                    Server
  │                         │
  │──── Data packet 1 ─────>│  (có thể đến)
  │──── Data packet 2 ─────>│  (có thể mất)
  │──── Data packet 3 ─────>│  (có thể đến trước packet 1)
  │                         │
  └─── Không có xác nhận ────┘
```

**Ví dụ:**
```javascript
// UDP Server - dgram.createSocket()
const server = dgram.createSocket('udp4');
server.on('message', (msg, rinfo) => {
    // rinfo chứa thông tin client (address, port)
    // Phải chỉ định rõ gửi cho ai
    server.send(result, rinfo.port, rinfo.address);
});

// UDP Client - gửi trực tiếp
const client = dgram.createSocket('udp4');
const msg = Buffer.from('Hello');
// Không cần connect, gửi luôn
client.send(msg, 5000, '127.0.0.1');
```

---

### So sánh TCP vs UDP

| Tiêu chí | TCP | UDP |
|----------|-----|-----|
| **Kết nối** | Cần thiết lập trước | Không cần |
| **Độ tin cậy** | 100% đảm bảo đến đích | Không đảm bảo |
| **Thứ tự** | Đúng thứ tự gửi | Có thể sai thứ tự |
| **Tốc độ** | Chậm hơn | Nhanh hơn |
| **Tài nguyên** | Tốn nhiều | Ít |
| **Phát hiện lỗi** | Có, tự động gửi lại | Không |
| **Module Node.js** | `net` | `dgram` |
| **Tạo server** | `net.createServer()` | `dgram.createSocket()` |
| **Gửi dữ liệu** | `socket.write(data)` | `socket.send(msg, port, address)` |
| **Nhận dữ liệu** | `socket.on('data')` | `socket.on('message')` |
| **Biết client** | Tự động (qua socket) | Phải lấy từ `rinfo` |

**Ví dụ:**
```javascript
// TCP - Gửi và nhận đơn giản
socket.write('Hello');           // Tự biết gửi cho ai
socket.on('data', (data) => {}); // Tự biết nhận từ ai

// UDP - Phải chỉ rõ
socket.send(msg, 5000, '127.0.0.1');              // Phải chỉ định port, address
socket.on('message', (msg, rinfo) => {            // rinfo chứa thông tin người gửi
    console.log(`Từ ${rinfo.address}:${rinfo.port}`);
});
```

---

### Khi nào dùng TCP?

**Dùng TCP khi:**
- **Cần đảm bảo dữ liệu đến đích đầy đủ**
- **Thứ tự tin nhắn quan trọng**
- **Chấp nhận chậm hơn một chút để đổi lấy độ tin cậy**

**Ví dụ thực tế:**

**Bài 1 - Giải phương trình:** Dùng TCP
- Lý do: Phải đảm bảo kết quả đúng 100% gửi về client
- Nếu mất kết quả → user không biết nghiệm của phương trình

**Bài 2 - Nhân ma trận:** Dùng TCP
- Lý do: Ma trận có nhiều số, mất 1 số → kết quả sai hoàn toàn
- Cần đảm bảo toàn bộ ma trận gửi đủ

**Bài 3 - Thay thế file:** Dùng TCP
- Lý do: File text phải đầy đủ, mất 1 dòng → file bị hỏng
- Cần đảm bảo nội dung file nguyên vẹn

**Bài 4 - Xử lý chuỗi:** Dùng TCP
- Lý do: Lệnh và tham số phải đầy đủ
- Nếu mất tham số → server xử lý sai

**Bài 5 - Chat room:** Dùng TCP
- Lý do: Tin nhắn phải đến đầy đủ, đúng thứ tự
- Nếu mất tin → cuộc trò chuyện không hiểu được

**Các ứng dụng khác dùng TCP:**
- Web browsing (HTTP/HTTPS)
- Email (SMTP, POP3, IMAP)
- File transfer (FTP, SFTP)
- Remote access (SSH, Telnet)
- Database connections

---

### Khi nào dùng UDP?

**Dùng UDP khi:**
- **Tốc độ quan trọng hơn độ tin cậy**
- **Chấp nhận mất một ít dữ liệu**
- **Dữ liệu gửi thường xuyên, liên tục**
- **Độ trễ (latency) phải thấp**

**Ví dụ thực tế:**

**Video call (Zoom, Skype):**
- Mất vài frame video → không sao, vẫn xem được
- Quan trọng là real-time, không bị giật lag
- TCP chậm → bị delay, không real-time

**Game online (PUBG, LOL, Valorant):**
- Vị trí nhân vật cập nhật liên tục (60 lần/giây)
- Mất 1-2 gói tin → không ảnh hưởng lớn (gói tin tiếp theo đã cập nhật vị trí mới)
- TCP chậm → bị lag, chết mất

**Live streaming (YouTube Live, Twitch):**
- Stream video/audio liên tục
- Mất vài khung hình → người xem không nhận ra
- Quan trọng là mượt, không đứng hình

**VoIP (gọi điện thoại qua mạng):**
- Giọng nói real-time
- Mất vài mili giây → không ảnh hưởng
- TCP chậm → thoại bị delay, nói không kịp

**DNS lookup:**
- Chỉ cần hỏi 1 lần: "google.com IP là gì?"
- Nếu không được → hỏi lại, đơn giản
- Không cần thiết lập kết nối phức tạp như TCP

**Sensor data (IoT):**
- Cảm biến gửi nhiệt độ mỗi giây: 25°C, 25°C, 26°C...
- Mất 1 giá trị → không sao, giá trị tiếp theo đã đến
- Quan trọng là nhanh, tốn ít pin

---

### Các khái niệm JavaScript trong code

**1. Callback Function**
```javascript
// Hàm được truyền như tham số, sẽ được gọi sau
function input(name, cb) {
    rl.question('Nhập: ', (answer) => {
        cb(answer);  // Gọi callback với kết quả
    });
}
```

**2. Arrow Function**
```javascript
// Cú pháp ngắn gọn
(param) => { return value }

// Tương đương:
function(param) { return value }
```

**3. Destructuring**
```javascript
// Lấy giá trị từ object
const { m1, m2 } = { m1: [[1,2]], m2: [[3,4]] };
// → m1 = [[1,2]], m2 = [[3,4]]

// Lấy giá trị từ array
const [a, b, c] = [1, 2, 3];
// → a = 1, b = 2, c = 3
```

**4. Spread Operator (...)**
```javascript
function processCommand(cmd, text, ...params) {
    // params là mảng chứa tất cả tham số còn lại
}
processCommand('DELETE', 'hello', 0, 5);  
// → cmd = 'DELETE', text = 'hello', params = [0, 5]
```

**5. JSON - Chuyển đổi dữ liệu**
```javascript
// Object → String (để gửi qua mạng)
const data = { m1: [[1,2]], m2: [[3,4]] };
const str = JSON.stringify(data);  
// → '{"m1":[[1,2]],"m2":[[3,4]]}'

// String → Object (sau khi nhận)
const obj = JSON.parse(str);  
// → { m1: [[1,2]], m2: [[3,4]] }
```

**6. Buffer - Dữ liệu nhị phân**
```javascript
// Socket nhận/gửi dữ liệu dạng Buffer
socket.on('data', (data) => {
    const str = data.toString();  // Buffer → String
});

const msg = Buffer.from('Hello');  // String → Buffer
socket.write(msg);
```

---

## Bài 1: Giải phương trình bậc 2

### File: `1_tcp_server.js`

```javascript
// Dòng 1: Import module 'net' để làm việc với TCP socket
const net = require('net');

// Dòng 3-14: Hàm giải phương trình ax² + bx + c = 0
function solve(a, b, c) {
    // Dòng 4: Tính delta theo công thức Δ = b² - 4ac
    const delta = b * b - 4 * a * c;
    
    // Dòng 5: Nếu delta < 0 → phương trình vô nghiệm (không có nghiệm thực)
    if (delta < 0) return 'Vô nghiệm';
    
    // Dòng 6-9: Nếu delta = 0 → nghiệm kép
    if (delta === 0) {
        // Dòng 7: Tính nghiệm kép x = -b / (2a)
        const x = -b / (2 * a);
        // Dòng 8: Trả về kết quả, toFixed(2) làm tròn 2 chữ số thập phân
        return `Nghiệm kép: x = ${x.toFixed(2)}`;
    }
    
    // Dòng 10-11: Nếu delta > 0 → 2 nghiệm phân biệt
    // Math.sqrt(delta) tính căn bậc 2 của delta
    const x1 = (-b + Math.sqrt(delta)) / (2 * a);  // Nghiệm 1
    const x2 = (-b - Math.sqrt(delta)) / (2 * a);  // Nghiệm 2
    // Dòng 12: Trả về cả 2 nghiệm
    return `x1 = ${x1.toFixed(2)}, x2 = ${x2.toFixed(2)}`;
}

// Dòng 16: Tạo TCP server
// net.createServer() nhận callback được gọi mỗi khi có client kết nối
// Tham số 'socket' là kết nối với client đó
const server = net.createServer((socket) => {
    // Dòng 17: In thông báo khi có client kết nối
    console.log('Client kết nối!');
    
    // Dòng 18: Lắng nghe sự kiện 'data' - khi nhận dữ liệu từ client
    socket.on('data', (data) => {
        // Dòng 19: Chuyển Buffer thành String và xóa khoảng trắng đầu/cuối
        const input = data.toString().trim();
        
        // Dòng 20: Tách chuỗi theo dấu cách, chuyển mỗi phần tử thành số
        // Ví dụ: "1 -5 6" → ["1", "-5", "6"] → [1, -5, 6]
        const nums = input.split(' ').map(Number);
        
        // Dòng 21: Destructuring - lấy 3 phần tử đầu làm a, b, c
        const [a, b, c] = nums;
        
        // Dòng 23: In ra phương trình nhận được
        console.log(`Nhận: ${a}x² + ${b}x + ${c} = 0`);
        
        // Dòng 24: Gọi hàm solve để giải phương trình
        const result = solve(a, b, c);
        
        // Dòng 25: Gửi kết quả về client qua socket
        socket.write(result);
        
        // Dòng 26: In kết quả đã gửi
        console.log(`Gửi: ${result}\n`);
    });
});

// Dòng 30: Cho server lắng nghe trên cổng 5000
// Callback được gọi khi server sẵn sàng
server.listen(5000, () => {
    console.log('Server chạy tại cổng 5000\n');
});
```

### File: `1_tcp_client.js`

```javascript
// Dòng 1-2: Import các module cần thiết
const net = require('net');              // Module TCP socket
const readline = require('readline');    // Module đọc input từ console

// Dòng 3: Tạo một socket client để kết nối đến server
const client = new net.Socket();

// Dòng 5-8: Tạo interface để đọc input từ bàn phím
const rl = readline.createInterface({
    input: process.stdin,    // Đọc từ bàn phím
    output: process.stdout   // Xuất ra console
});

// Dòng 10: Kết nối đến server
// Tham số: (port, host, callback khi kết nối thành công)
client.connect(5000, '127.0.0.1', () => {
    // Dòng 11-12: In thông báo khi kết nối thành công
    console.log('Kết nối thành công!');
    console.log('Nhập 3 số a b c (cách nhau bởi dấu cách)\n');
    
    // Dòng 13: Gọi hàm để bắt đầu nhập dữ liệu
    askInput();
});

// Dòng 16-20: Hàm hỏi người dùng nhập 3 số
function askInput() {
    // Dòng 17: Hiển thị prompt và đợi người dùng nhập
    rl.question('Nhập a b c: ', (input) => {
        // Dòng 18: Khi người dùng nhấn Enter, gửi dữ liệu đến server
        client.write(input);
    });
}

// Dòng 22-25: Lắng nghe dữ liệu từ server
client.on('data', (data) => {
    // Dòng 23: In kết quả nhận được từ server
    console.log(`→ ${data}\n`);
    
    // Dòng 24: Hỏi tiếp để nhập bộ số mới
    askInput();
});

// Dòng 27-30: Xử lý khi kết nối bị đóng
client.on('close', () => {
    // Dòng 28: In thông báo
    console.log('Ngắt kết nối');
    // Dòng 29: Đóng readline interface
    rl.close();
});
```

---

## Bài 2: Nhân hai ma trận

### File: `2_tcp_server.js`

```javascript
// Dòng 1: Import module net
const net = require('net')

// Dòng 3-13: Hàm nhân 2 ma trận
// Tham số: a = ma trận A[m×n], b = ma trận B[n×p]
// Kết quả: ma trận C[m×p]
function solve(a, b){
    // Dòng 4: Khởi tạo mảng kết quả rỗng
    const res = [];
    
    // Dòng 5: Vòng lặp qua từng hàng của ma trận A
    for(let i=0; i<a.length; ++i){
        // Dòng 6: Tạo hàng thứ i của kết quả
        res[i] = [];
        
        // Dòng 7: Vòng lặp qua từng cột của ma trận B
        for(let j=0; j<b[0].length; ++j){
            // Dòng 8: Khởi tạo phần tử res[i][j] = 0
            res[i][j] = 0;
            
            // Dòng 9-10: Tính tổng tích
            // res[i][j] = a[i][0]*b[0][j] + a[i][1]*b[1][j] + ... + a[i][k]*b[k][j]
            for(let k=0; k<b.length; ++k)
                res[i][j] += a[i][k]*b[k][j];  // Nhân và cộng dồn
        }
    }
    // Dòng 12: Trả về ma trận kết quả
    return res; 
}

// Dòng 15: Tạo TCP server
const server = net.createServer((socket) => {
    // Dòng 16: In thông báo khi client kết nối
    console.log('Client connect');
    
    // Dòng 17: Lắng nghe dữ liệu từ client
    socket.on('data', (data) => {
        // Dòng 18: Parse JSON thành object
        // Client gửi dạng: {"m1": [[1,2],[3,4]], "m2": [[5,6],[7,8]]}
        const {m1, m2} = JSON.parse(data);
        
        // Dòng 19: Gọi hàm nhân ma trận
        const ans = solve(m1, m2);
        
        // Dòng 20: In kết quả ra console
        console.log('Ket qua', ans, '\n');
        
        // Dòng 21: Chuyển kết quả thành JSON string và gửi về client
        socket.write(JSON.stringify(ans));
        
        // Dòng 22: In thông báo đã gửi
        console.log('Gui');
    });
});

// Dòng 26: Lắng nghe trên cổng 5000
server.listen(5000, () => {
    console.log('Serer chay ...')
});
```

### File: `2_tcp_client.js`

```javascript
// Dòng 1-2: Import module
const net = require('net');
const readline = require('readline');

// Dòng 4: Tạo socket client
const client = new net.Socket();

// Dòng 5: Tạo readline interface
const rl = readline.createInterface({ input: process.stdin, output: process.stdout });

// Dòng 7-16: Hàm hiển thị ma trận đẹp
function show(m, name) {
    // Dòng 8: In tên ma trận
    console.log(`${name}:`);
    
    // Dòng 9: Vòng lặp qua từng hàng
    for(let i=0; i<m.length; i++){
        // Dòng 10: Tạo chuỗi cho 1 hàng, bắt đầu bằng 2 dấu cách
        let row = '  ';
        
        // Dòng 11: Vòng lặp qua từng cột
        for(let j=0; j<m[i].length; j++){
            // Dòng 12: Thêm giá trị vào chuỗi, cách nhau 2 khoảng trắng
            row += m[i][j] + '  ';
        }
        // Dòng 14: In chuỗi hàng ra console
        console.log(row);
    }
}

// Dòng 17-31: Hàm nhập ma trận từ người dùng
// Tham số: name = tên ma trận, cb = callback function
function input(name, cb){
    // Dòng 18: Hỏi kích thước ma trận (số hàng r, số cột c)
    rl.question(`${name} (Kích thước n, m): `, (size) => {
        // Dòng 19: Parse thành 2 số
        const [r, c] = size.split(' ').map(Number);
        
        // Dòng 20: Hỏi nhập tất cả các số (r*c số)
        rl.question(`Nhập ${r*c} số: `, (line) => {
            // Dòng 21: Tách chuỗi thành mảng số
            const n = line.split(' ').map(Number);
            
            // Dòng 22: Khởi tạo ma trận rỗng
            const m = [];
            
            // Dòng 23: Vòng lặp tạo từng hàng
            for(let i=0; i<r; i++){
                // Dòng 24: Tạo hàng thứ i
                m[i] = [];
                
                // Dòng 25: Vòng lặp tạo từng cột
                for(let j=0; j<c; j++){
                    // Dòng 26: Lấy số từ mảng n theo công thức: vị trí = i*c + j
                    // Ví dụ r=2, c=2: [1,2,3,4] → [[1,2],[3,4]]
                    m[i][j] = n[i*c + j];
                }
            }
            // Dòng 29: Gọi callback với ma trận đã tạo
            cb(m);
        });
    });
}

// Dòng 33-36: Kết nối đến server
client.connect(5000, '127.0.0.1', () => {
    // Dòng 34: In thông báo kết nối OK
    console.log('OK\n');
    // Dòng 35: Bắt đầu nhập liệu
    ask();
});

// Dòng 38-44: Hàm điều khiển luồng nhập liệu
function ask(){
    // Dòng 39: Nhập ma trận A
    input('Ma trận A : ', (m1) => {
        // Dòng 40: Sau khi nhập xong A, nhập ma trận B
        input('Ma trận B', (m2) => {
            // Dòng 41: In thông báo
            console.log('\nGửi lên server ...');
            
            // Dòng 42: Gửi 2 ma trận dạng JSON đến server
            client.write(JSON.stringify({ m1, m2 }));
        });
    });
}

// Dòng 46-51: Nhận kết quả từ server
client.on('data', (data) => {
    // Dòng 47: Parse JSON thành ma trận và hiển thị
    show(JSON.parse(data), 'Kết quả ma trận A×B');
    
    // Dòng 48: Hỏi có muốn tiếp tục không
    rl.question('\nTiếp? (y/n): ', (a) => {
        // Dòng 49: Nếu nhập 'y', tiếp tục
        if (a === 'y') ask();
        // Dòng 50: Nếu không, đóng kết nối
        else { client.destroy(); rl.close(); }
    });
});
```

---

## Bài 3: Thay thế chuỗi trong file

### File: `3_tcp_server.js`

```javascript
// Dòng 1: Import module net
const net = require('net');

// Dòng 3-5: Hàm thay thế tất cả s1 thành s2 trong content
function replaceAll(content, s1, s2) {
    // Dòng 4: Split chuỗi theo s1, rồi join lại bằng s2
    // Ví dụ: "Hello world Hello" với s1="Hello", s2="Hi"
    // → ["", " world ", ""] → "Hi world Hi"
    return content.split(s1).join(s2);
}

// Dòng 7: Tạo TCP server
const server = net.createServer((socket) => {
    // Dòng 8: In thông báo
    console.log('Client kết nối!\n');
    
    // Dòng 10: Lắng nghe dữ liệu từ client
    socket.on('data', (data) => {
        // Dòng 11-12: Parse JSON để lấy file content và 2 chuỗi
        const request = JSON.parse(data.toString());
        const { fileContent, s1, s2 } = request;
        
        // Dòng 14-15: In thông tin nhận được
        console.log(`Nhận file (${fileContent.length} ký tự)`);
        console.log(`Thay thế: "${s1}" → "${s2}"`);
        
        // Dòng 16: Gọi hàm thay thế
        const result = replaceAll(fileContent, s1, s2);
        
        // Dòng 17: Đếm số lần xuất hiện của s1
        // Cách đếm: split theo s1 sẽ tạo ra (n+1) phần, với n là số lần xuất hiện
        const count = (fileContent.split(s1).length - 1);
        
        // Dòng 19: In số lần thay thế
        console.log(`Đã thay thế ${count} lần\n`);
        
        // Dòng 20: Gửi kết quả về client dạng JSON
        socket.write(JSON.stringify({ result, count }));
    });
});

// Dòng 24: Lắng nghe trên cổng 5002
server.listen(5002, () => {
    console.log('Server chạy tại cổng 5002\n');
});
```

---

## Bài 4: Xử lý chuỗi

### File: `4_tcp_server.js`

```javascript
// Dòng 1: Import module net
const net = require('net');

// Dòng 3-23: Hàm xử lý các lệnh khác nhau
// Tham số: cmd = tên lệnh, text = chuỗi cần xử lý, ...params = các tham số thêm
function processCommand(cmd, text, ...params) {
    // Dòng 4: Switch-case kiểm tra lệnh
    switch(cmd) {
        // Dòng 5-6: Lệnh UPPER - chuyển thành chữ HOA
        case 'UPPER':
            return text.toUpperCase();
        
        // Dòng 7-8: Lệnh LOWER - chuyển thành chữ thường
        case 'LOWER':
            return text.toLowerCase();
        
        // Dòng 9-12: Lệnh DELETE - xóa 1 đoạn chuỗi
        case 'DELETE':
            // Dòng 11: Lấy vị trí bắt đầu và kết thúc từ params
            const [start, end] = params.map(Number);
            // Dòng 12: Cắt 2 đoạn và nối lại
            // Ví dụ: "hello world" với start=0, end=5 → "" + " world" = " world"
            return text.slice(0, start) + text.slice(end);
        
        // Dòng 13-17: Lệnh INSERT - chèn chuỗi con
        case 'INSERT':
            // Dòng 15-16: Lấy vị trí và chuỗi con cần chèn
            const pos = Number(params[0]);
            const substr = params[1];
            // Dòng 17: Cắt làm 2 đoạn, chèn substr vào giữa
            // Ví dụ: "hello" với pos=5, substr=" world" → "hello" + " world" + "" = "hello world"
            return text.slice(0, pos) + substr + text.slice(pos);
        
        // Dòng 18-19: Lệnh không hợp lệ
        default:
            return 'Lệnh không hợp lệ';
    }
}

// Dòng 22: Tạo TCP server
const server = net.createServer((socket) => {
    // Dòng 23: In thông báo
    console.log('Client kết nối!\n');
    
    // Dòng 25: Lắng nghe dữ liệu từ client
    socket.on('data', (data) => {
        // Dòng 26-27: Parse dữ liệu
        // Format: "UPPER|hello world" → ["UPPER", "hello world"]
        const parts = data.toString().split('|');
        // Destructuring: phần tử đầu là cmd, thứ 2 là text, còn lại là params
        const [cmd, text, ...params] = parts;
        
        // Dòng 29-31: In thông tin nhận được
        console.log(`Lệnh: ${cmd}`);
        console.log(`Text: ${text}`);
        console.log(`Params: ${params.join(', ')}`);
        
        // Dòng 33: Gọi hàm xử lý lệnh
        const result = processCommand(cmd, text, ...params);
        // Dòng 34: In kết quả
        console.log(`→ ${result}\n`);
        
        // Dòng 36: Gửi kết quả về client
        socket.write(result);
    });
});

// Dòng 40-42: Lắng nghe trên cổng 5003
server.listen(5003, () => {
    console.log('Server chạy cổng 5003');
    console.log('Lệnh: UPPER, LOWER, DELETE, INSERT\n');
});
```

---

## Bài 5: Chat room

### File: `5_tcp_server.js`

```javascript
// Dòng 1-2: Import module
const net = require('net');
const readline = require('readline');

// Dòng 4: Mảng lưu tất cả client đang kết nối
const clients = [];

// Dòng 5: Tạo TCP server
const server = net.createServer((socket) => {
    
    // Dòng 7: Gửi yêu cầu nhập tên cho client mới
    socket.write('Nhập tên của bạn: ');
    
    // Dòng 8-9: Biến lưu trạng thái
    let username = '';     // Tên người dùng
    let isNamed = false;   // Đã nhập tên chưa
    
    // Dòng 11: Lắng nghe dữ liệu từ client
    socket.on('data', (data) => {
        // Dòng 12: Lấy message và xóa khoảng trắng
        const msg = data.toString().trim();
        
        // Dòng 14-23: Nếu chưa nhập tên
        if (!isNamed) {
            // Dòng 15: Lưu tên
            username = msg;
            
            // Dòng 16: Thêm client vào danh sách
            clients.push({ socket, username });
            
            // Dòng 17: In thông báo server
            console.log(`[+] ${username} tham gia (${clients.length} online)\n`);
            
            // Dòng 19: Thông báo cho tất cả client khác
            broadcast(`[SERVER] ${username} đã tham gia chat!`, socket);
            
            // Dòng 20: Gửi lời chào cho client vừa vào
            socket.write(`Chào ${username}! Gõ tin nhắn để chat.\n\n`);
            
            // Dòng 21-22: Đánh dấu đã nhập tên, thoát khỏi hàm
            isNamed = true;
            return;
        }
        
        // Dòng 25-26: Nếu đã nhập tên → xử lý tin nhắn chat
        // Format tin nhắn: "[username]: message"
        const message = `[${username}]: ${msg}`;
        
        // Dòng 27: In tin nhắn ra server console
        console.log(message);
        
        // Dòng 28: Gửi tin nhắn cho tất cả client (trừ người gửi)
        broadcast(message, socket);
        
        // Dòng 30-31: Xác nhận đã gửi cho người gửi
        socket.write('✓ Đã gửi\n');
    });
    
    // Dòng 34-41: Xử lý khi client ngắt kết nối
    socket.on('close', () => {
        // Dòng 35-36: Tìm vị trí của client trong mảng
        const index = clients.findIndex(c => c.socket === socket);
        
        // Dòng 37: Nếu tìm thấy
        if (index !== -1) {
            // Dòng 38: Xóa khỏi mảng (1 phần tử tại vị trí index)
            clients.splice(index, 1);
            
            // Dòng 39: In thông báo server
            console.log(`[-] ${username} rời khỏi (${clients.length} online)\n`);
            
            // Dòng 40: Thông báo cho tất cả client còn lại
            broadcast(`[SERVER] ${username} đã rời khỏi!`);
        }
    });
});

// Dòng 44-50: Hàm broadcast - gửi tin nhắn cho tất cả client
// Tham số: message = nội dung, exclude = socket cần loại trừ (không gửi)
function broadcast(message, exclude = null) {
    // Dòng 45: Duyệt qua tất cả client
    clients.forEach(client => {
        // Dòng 46-48: Nếu không phải client cần loại trừ
        if (client.socket !== exclude) {
            // Gửi tin nhắn
            client.socket.write(message + '\n');
        }
    });
}

// Dòng 52-57: Lắng nghe trên cổng 5004
server.listen(5004, () => {
    console.log('='.repeat(40));
    console.log('  CHAT ROOM SERVER - TCP');
    console.log('  Port: 5004');
    console.log('='.repeat(40) + '\n');
});
```

---

## Cách chạy

```bash
# TCP - Luôn chạy server trước
node 1_tcp_server.js  # Terminal 1
node 1_tcp_client.js  # Terminal 2

# UDP (tương tự)
node 1_udp_server.js
node 1_udp_client.js
```
